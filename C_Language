/*작성자: 금기현	작성일: 2019.01.28
 * 1. 구조체를 선언하여 단어와 뜻을 입력 받아 5가지 메뉴(입력하기, 출력하기, 검색하기, 삭제하기, 종료)로
 *	처리하는 프로그램을 작성하시오.
 * 2. 단어의 길이는 19문자 이하이며, 단어의 뜻은 79문자 이하로 입력된다고 가정한다.
 * 3. 사전에 저장 가능한 최대 단어의 개수는 10개이며, 단어 입력 및 삭제를 반복하더라도 10개를 초과하지 않도록 해야한다.
 */
#pragma warning (disable:4996)
#include <stdio.h>
#include <string.h>
#define WORDLEN 20
#define MEANLEN 80

enum { Input = 1, Output, Search, Delete, Quit };

typedef struct dic {
	char word[20];
	char mean[80];
	int len;
}Dic;

typedef struct dicAry {
	Dic ary[10];
	int arylen; 
}DicAry; // Dic구조체 배열과 배열에 저장된 Data의 갯수를 관리하는 구조체

void menuPrint(const char **menu, size_t size, void(*showData)(const char *msg, int idx));
void printTwoLine(const char *msg, int idx);
int inputInt(const char *msg);
void InputStr(const char *msg, char *str, size_t len);
void myFlush();

void inputDic(DicAry *dp);
void outputDic(DicAry *dp);
void sortDic(DicAry *dp);
void sortData(void *ary, size_t size, int arylen, int(*compareData)(void *, void*), void(*swapData)(void *, void *));
// generic기법으로 짜본 sort함수
int compareDic(void *vp1, void *vp2);
void swapDic(void *vp1, void* vp2);
// generic기법 sort함수의 보조함수
void searchDic(DicAry *dp);
void deleteDic(DicAry *dp);
int searchIdx(DicAry *dp, char *word);
void deleteIdx(DicAry *dp, int idx);

int main()
{
	const char *mainMenu[] = { "입력하기", "출력하기", "검색하기", "삭제하기", "종료" };
	int choice;
	DicAry diction; 
	diction.arylen = 0; // 배열의 길이를 0으로 초기화

	while (1) {
		menuPrint(mainMenu, sizeof(mainMenu) / sizeof(mainMenu[0]), printTwoLine);
		choice = inputInt("# 메뉴선택: ");
		switch (choice) {
		case Input: inputDic(&diction); break;
		case Output: outputDic(&diction); break;
		case Search: searchDic(&diction); break;
		case Delete: deleteDic(&diction); break;
		case Quit: ; return 0;
		default: break;
		}
	}
}

void menuPrint(const char **menu, size_t size, void(*showData)(const char *msg, int idx)) {
	for (size_t i = 0; i < size; i++) {
		showData(menu[i], i + 1);
	}
	printf("\n");
}

void printTwoLine(const char *msg, int idx) {
	printf("%d. %s", idx, msg);
	if (idx % 2 == 0) printf("\n");
	else printf("%4c", ' ');
}

int inputInt(const char *msg) {
	int posNum;
	while (1) {
		printf(msg);
		scanf("%d", &posNum);
		if (getchar() == '\n') {
			break;
		}
		else {
			printf("정수 이외의 문자가 입력됨.\n");
			myFlush();
		}
	}
	return posNum;
}

void InputStr(const char *msg, char *str, size_t len) {
	printf(msg);
	fgets(str, len, stdin);
	if (str[strlen(str) - 1] == '\n') {
		str[strlen(str) - 1] = '\0';
	}
	else {
		printf("문자열의 길이를 초과하여 일부 문자열이 잘립니다.\n");
		str[strlen(str) - 1] = '\0';
		myFlush();
	}
}

void myFlush() {
	while (getchar() != '\n');
}

void inputDic(DicAry *dp) {
	while (dp->arylen < 10) {
		InputStr("# 단어를 입력하시오: ", dp->ary[dp->arylen].word, WORDLEN);
		if (strcmp(dp->ary[dp->arylen].word, "end") == 0) {
			memset(dp->ary[dp->arylen].word, 0, WORDLEN);
			break;
		}
		dp->ary[dp->arylen].len = strlen(dp->ary[dp->arylen].word);
		InputStr("# 뜻을 입력하시오: ", dp->ary[dp->arylen].mean, MEANLEN);
		++dp->arylen;
		printf("\n");
	}
}

void outputDic(DicAry *dp) {
	if (dp->arylen == 0) {
		printf("data가 없습니다.\n\n");
		return;
	}
	//sortDic(dp);
	sortData(dp->ary, sizeof(dp->ary[0]), dp->arylen, compareDic, swapDic);
	for (int i = 0; i < dp->arylen; i++) {
		printf("%d.%20s(%2d) : ", i + 1, dp->ary[i].word, dp->ary[i].len);
		if (strlen(dp->ary[i].mean) > 50) {
			for (int idx = 0; idx < 50; idx++) {
				printf("%c", dp->ary[i].mean[idx]);
			}
			printf("~\n");
		}
		else {
			printf("%s\n", dp->ary[i].mean);
		}
	}
	printf("\n");
}

void sortDic(DicAry *dp) {
	Dic temp;
	for (int i = dp->arylen - 1; i >= 0; i--) {
		int max = 0;
		for (int j = 1; j <= i; j++) {
			if (strcmp(dp->ary[j].word, dp->ary[max].word) > 0)
				max = j;
		}
		temp = dp->ary[i]; dp->ary[i] = dp->ary[max]; dp->ary[max] = temp;
	}
}

void sortData(void *ary, size_t size,int arylen, int (*compareData)(void *, void*), void (*swapData)(void *, void *)) {
	for (int i = arylen - 1; i >= 0; i--) {
		int max = 0;
		for (int j = 1; j <= i; j++) {
			if (compareData((char *)ary + j * size, (char *)ary + max * size) > 0)
				max = j;
		}
		swapData((char *)ary + i * size, (char *)ary + max * size);
		printf("max: %d\n", max);
	}
}

int compareDic(void *vp1, void *vp2) {
	return strcmp(((Dic *)vp1)->word, ((Dic *)vp2)->word);
}

void swapDic(void *vp1, void* vp2) {
	Dic temp;
	temp = *(Dic *)vp1;
	*(Dic *)vp1 = *(Dic *)vp2;
	*(Dic *)vp2 = temp;
}

void searchDic(DicAry *dp) {
	if (dp->arylen == 0) {
		printf("data가 없습니다.\n\n");
		return;
	}
	int idx;
	char word[WORDLEN];
	while (1) {
		InputStr("# 찾을 단어를 입력하시오: ", word, WORDLEN);
		if (strcmp(word, "end") == 0)
			break;
		idx = searchIdx(dp, word);
		if (idx >= dp->arylen)
			printf("  해당 안어는 존재하지 않습니다.\n\n");
		else {
			printf("  단어의 뜻: %s\n\n", dp->ary[idx].mean);
		}
	}
	printf("\n");
}

void deleteDic(DicAry *dp) {
	if (dp->arylen == 0) {
		printf("data가 없습니다.\n\n");
		return;
	}
	int idx;
	char word[WORDLEN], choice;
	while (1) {
		InputStr("# 삭제할 단어를 입력하시오: ", word, WORDLEN);
		if (strcmp(word, "end") == 0)
			break;
		idx = searchIdx(dp, word);
		if (idx >= dp->arylen)
			printf("  해당 안어는 존재하지 않습니다.\n\n");
		else {
			printf("# 정말로 삭제하시겠습니까?(y/n): ");
			scanf(" %c", &choice);
			if (choice == 'y') {
				deleteIdx(dp, idx);
				printf("  삭제되었습니다.\n\n");
			}
			else if (choice == 'n') {
				printf("  삭제가 취소되었습니다.\n\n");
			}
			else {
				printf("  옳바르지 않은 문자가 입력되었습니다. 삭제를 취소합니다.\n\n");
			}
			myFlush();
		}
	}
	printf("\n");
}

int searchIdx(DicAry *dp, char *word) {
	int idx;
	for (idx = 0; idx < dp->arylen; idx++) {
		if (strcmp(dp->ary[idx].word, word) == 0)
			break;
	}
	return idx;
}

void deleteIdx(DicAry *dp, int idx) {
	dp->ary[idx] = dp->ary[--dp->arylen];
}
